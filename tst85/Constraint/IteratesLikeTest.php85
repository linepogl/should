<?php // This file is autogenerated

declare(strict_types=1);

namespace Tests\Constraint;

use ArrayIterator;
use Exception;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\TestCase;
use Should\Constraint\IteratesLike;
use Should\Constraint\Util\Util;

use function Should\shouldBe;
use function Should\shouldIterateLike;
use function Should\shouldNotThrow;
use function Should\shouldThrow;

class IteratesLikeTest extends TestCase
{
    /**
     * @return iterable<string, array{iterable<mixed, mixed>, mixed}|array{iterable<mixed, mixed>, mixed, ?string}>
     */
    public static function cases(): iterable
    {
        yield 'array 1' => [[], []];
        yield 'array 2' => [[], [1], 'Failed asserting that two iterables iterate the same way.'];

        yield 'array 3' => [['a' => 1, 'b' => 2], ['a' => 1, 'b' => 2]];
        yield 'array 4' => [['a' => 1, 'b' => 2], ['b' => 2, 'a' => 1], 'Failed asserting that two iterables iterate the same way.'];
        yield 'array 5' => [['a' => 1, 'b' => 2], ['a' => 1, 'b' => '2'], 'Failed asserting that two iterables iterate the same way.'];
        yield 'array 6' => [['a' => 1, 'b' => 2], ['a' => 1, 'b' => 2, 'c' => 3], 'Failed asserting that two iterables iterate the same way.'];
        yield 'array 7' => [['a' => 1, 'b' => 2], ['a' => 1], 'Failed asserting that two iterables iterate the same way.'];

        yield 'not iterable' => [['a' => 1, 'b' => 2], 1, 'Failed asserting that 1 is of type iterable.'];
    }

    /**
     * @param iterable<mixed, mixed> $expected
     */
    #[DataProvider('cases')]
    public function test_iterates_like(iterable $expected, mixed $actual, ?string $error = null, ?string $expectedAsString = null, ?string $actualAsString = null): void
    {
        $constraint = new IteratesLike($expected);
        if (null === $error) {
            $constraint->evaluate($actual, '', true) |> shouldBe(true);
            shouldNotThrow()(static fn() => $constraint->evaluate($actual));
        } else {
            $constraint->evaluate($actual, '', true) |> shouldBe(false);
            shouldThrow(Util::expectationFailure($error, $expected, $actual, $expectedAsString, $actualAsString))(
                static fn() => $constraint->evaluate($actual)
            );
            shouldThrow(Util::expectationFailure('Custom message', $expected, $actual, $expectedAsString, $actualAsString, $error))(
                static fn() => $constraint->evaluate($actual, 'Custom message')
            );
        }
    }

    public function test_iterates_like_rewind(): void
    {
        shouldNotThrow()(
            static fn()
            => [1, 2]
            |> shouldIterateLike([1, 2], rewind: true)
        );

        shouldNotThrow()(
            static fn()
            => new ArrayIterator([1, 2])
            |> shouldIterateLike([1, 2], rewind: true)
        );

        $generator = (static function () {
            yield 1;
            yield 2;
        })();
        shouldThrow(new Exception('Cannot traverse an already closed generator'))(
            static fn()
            => $generator
            |> shouldIterateLike([1, 2], rewind: true)
        );
    }

    public function test_to_string(): void
    {
        new IteratesLike([1, 2])->toString() |> shouldBe('iterates like an array');
        new IteratesLike([1, 2], rewind: true)->toString() |> shouldBe('iterates like an array and rewinds');
    }
}
